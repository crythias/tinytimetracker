head	1.3;
access;
symbols;
locks
	gyoung:1.3; strict;
comment	@# @;


1.3
date	2007.06.15.05.32.02;	author rblack;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.15.05.31.29;	author rblack;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.14.20.12.44;	author afuqua;	state Exp;
branches;
next	;


desc
@@


1.3
log
@made fields private
@
text
@package tracker;

import java.io.*;
import java.nio.channels.FileLock;

public class MultipleInstancesLock {
    private File lockFile;
    private FileLock multipleInstanceLock;
    
    public MultipleInstancesLock(File lockFile) {
        this.lockFile = lockFile;
    }
    
    /**
     * Locks lockFile if a lock can be acquired. If the lock cannot
     * be acquired, this method logs a message and throws an exception. 
     * TinyTimeTracker should not continue if a lock cannot be acquired.
     * Be nice and allowOtherInstances before exiting.
     * @@param lockFile
     * @@throws MultipleInstancesException
     * @@see Tracker#allowOtherInstances
     */
    public void preventMultipleInstances() throws MultipleInstancesException {
        try {
            FileOutputStream fos = new FileOutputStream(lockFile);
            multipleInstanceLock = fos.getChannel().tryLock();
        } catch (Exception e) {
            final String message = "Multiple instances must be running because we got an exception trying to acquire a lock on "+lockFile.toString();
            System.err.println(message);
            e.printStackTrace();
            throw new MultipleInstancesException(message,e);
        }
        if (multipleInstanceLock == null) {
            final String message = "Multiple instances must be running because I could not acquire a lock on "+lockFile.toString();
            System.err.println(message);
            throw new MultipleInstancesException(message);
        }
    }

    /**
     * Allows other instances of TinyTimeTracker to run. Be nice and call this
     * before exiting. However, if this isn't called, the lock will be released
     * by the OS when the jvm exits.
     */
    public void allowOtherInstances() {
        try {
            if (multipleInstanceLock != null) {
                multipleInstanceLock.release();
                // We don't HAVE to close the channel or delete the file, but I like to anyway.
                // There is the slight danger of a race condition of another instance starting
                // after the release and before the delete, but I'll accept that risk.
                multipleInstanceLock.channel().close();
                lockFile.delete();
            }
        } catch (IOException ignore) {
            ignore.printStackTrace();
        }
    }
}
@


1.2
log
@made methods public
@
text
@d7 2
a8 2
    File lockFile;
    FileLock multipleInstanceLock;
@


1.1
log
@prevent multiple instances of tiny time tracker from running at the same time
@
text
@d3 1
a3 4
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
d23 1
a23 1
    void preventMultipleInstances() throws MultipleInstancesException {
d45 1
a45 1
    void allowOtherInstances() {
@

